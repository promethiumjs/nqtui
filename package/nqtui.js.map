{"mappings":"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","sources":["src/nqtui.ts","src/render.ts","src/h.ts","src/queueRevertChangedToTrue.ts","src/adaptations/adaptations.ts","src/adaptations/adaptEffect/adaptSyncEffect.ts","src/adaptations/adaptEffect/createEffect.ts","src/adaptations/adaptEffect/executeFns.ts","src/adaptations/adaptEffect/effectAndDescendantCeanup.ts","src/adaptations/getCleanupNode.ts","src/adaptations/observableSubscriptionsCleanup.ts","src/adaptations/effectContexts.ts","src/adaptations/adaptEffect/sendSignal.ts","src/adaptations/adaptEffect/addAsyncEffect.ts","src/adaptations/adaptEffect/addRenderEffect.ts","src/adaptations/setInitialParameters.ts","src/adaptations/setCleanupSet.ts","src/adaptations/adaptState/adaptState.ts","src/adaptations/get.ts","src/adaptations/adaptState/set.ts","src/adaptations/cleanupUpdateFns.ts","src/adaptations/sendSignals.ts","src/adaptations/adaptEffect/adaptEffect.ts","src/adaptations/adaptEffect/adaptRenderEffect.ts","src/adaptations/adaptMemo/adaptMemo.ts","src/adaptations/adaptMemo/sendSignal.ts","src/adaptations/adaptMemo/notifyAndUpdate.ts"],"sourcesContent":["import { render } from \"./render\";\nimport type { Component } from \"./render\";\nimport type { TemplateResult } from \"lit-html\";\nimport type { DirectiveResult } from \"lit-html/directive.js\";\nimport h from \"./h\";\nimport { html } from \"lit-html\";\nimport adaptState from \"./adaptations/adaptState/adaptState\";\nimport adaptEffect from \"./adaptations/adaptEffect/adaptEffect\";\nimport adaptRenderEffect from \"./adaptations/adaptEffect/adaptRenderEffect\";\nimport adaptSyncEffect from \"./adaptations/adaptEffect/adaptSyncEffect\";\nimport adaptMemo from \"./adaptations/adaptMemo/adaptMemo\";\nimport { classMap } from \"lit-html/directives/class-map.js\";\nimport { styleMap } from \"lit-html/directives/style-map.js\";\nimport { when } from \"lit-html/directives/when.js\";\nimport { choose } from \"lit-html/directives/choose.js\";\nimport { map } from \"lit-html/directives/map.js\";\nimport { repeat } from \"lit-html/directives/repeat.js\";\nimport { join } from \"lit-html/directives/join.js\";\nimport { range } from \"lit-html/directives/range.js\";\nimport { ifDefined } from \"lit-html/directives/if-defined.js\";\nimport { cache } from \"lit-html/directives/cache.js\";\nimport { keyed } from \"lit-html/directives/keyed.js\";\nimport { guard } from \"lit-html/directives/guard.js\";\nimport { live } from \"lit-html/directives/live.js\";\nimport { ref } from \"lit-html/directives/ref.js\";\nimport { createRef } from \"lit-html/directives/ref.js\";\nimport { templateContent } from \"lit-html/directives/template-content.js\";\nimport { unsafeHTML } from \"lit-html/directives/unsafe-html.js\";\nimport { unsafeSVG } from \"lit-html/directives/unsafe-svg.js\";\nimport { until } from \"lit-html/directives/until.js\";\nimport { asyncAppend } from \"lit-html/directives/async-append.js\";\nimport { asyncReplace } from \"lit-html/directives/async-replace.js\";\n\nexport {\n  Component,\n  render,\n  TemplateResult,\n  DirectiveResult,\n  h,\n  html,\n  adaptState,\n  adaptEffect,\n  adaptRenderEffect,\n  adaptSyncEffect,\n  adaptMemo,\n  classMap,\n  styleMap,\n  when,\n  choose,\n  guard,\n  cache,\n  keyed,\n  map,\n  repeat,\n  join,\n  range,\n  live,\n  ifDefined,\n  ref,\n  createRef,\n  templateContent,\n  unsafeHTML,\n  unsafeSVG,\n  until,\n  asyncAppend,\n  asyncReplace,\n};\n","import {\n  render as internalRender,\n  html,\n  TemplateResult,\n  RootPart,\n} from \"lit-html\";\nimport h from \"./h\";\n\nexport type Component<T = null> = T extends null\n  ? (props?: null) => () => TemplateResult\n  : (props: T) => () => TemplateResult;\n\nexport function render(\n  Component: Component<{\n    renderContainer: string | HTMLElement | DocumentFragment;\n    renderOptions?: Object;\n  }>,\n  props: {\n    renderContainer: string | HTMLElement | DocumentFragment;\n    renderOptions?: Object;\n  }\n): () => RootPart {\n  //check whether or not \"renderContainer\" is a string and handle it\n  //accordingly.\n  if (\n    typeof props.renderContainer === \"string\" ||\n    props.renderContainer instanceof String\n  )\n    props.renderContainer = document.querySelector(\n      props.renderContainer as any\n    );\n\n  const renderComponent = () =>\n    internalRender(\n      html`${h(Component, props)}`,\n      props.renderContainer as HTMLElement | DocumentFragment,\n      props.renderOptions\n    );\n\n  //queue microtask to render the component to enable all extensions to run first.\n  queueMicrotask(renderComponent);\n\n  //return \"renderComponent\" function to allow re-rendering of whole root\n  //component tree.\n  return renderComponent;\n}\n","import {\n  AsyncDirective,\n  directive,\n  DirectiveResult,\n  PartInfo,\n} from \"lit-html/async-directive.js\";\nimport queueRevertChangedToTrue from \"./queueRevertChangedToTrue\";\nimport { renderComponent } from \"./adaptations/adaptations\";\nimport adaptSyncEffect from \"./adaptations/adaptEffect/adaptSyncEffect\";\nimport { ChildPart, noChange, TemplateResult } from \"lit-html\";\nimport { Component } from \"./render\";\n\nclass $ extends AsyncDirective {\n  updateFlag: \"initialize\" | \"externalRender\";\n  cleanups: any[];\n  ComponentDependencyUpdate: any;\n  Component: () => TemplateResult;\n  changed: boolean;\n  props: any;\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n\n    //boolean flag to enable initialization of the component in the update method.\n    this.updateFlag = \"initialize\";\n  }\n\n  protected disconnected(): void {\n    this.cleanups.forEach((cleanup) => cleanup());\n  }\n\n  //normal render process\n  externalRender(props: any) {\n    for (const prop in props) {\n      this.props[prop] = props[prop];\n    }\n\n    return this.render();\n  }\n\n  //first time initialization of component\n  initialize(\n    props: any,\n    part: ChildPart,\n    Component: (props: any, parent: Node) => () => TemplateResult\n  ) {\n    this.props = props;\n\n    return this.initializeComponent(Component, part.parentNode, this.props);\n  }\n\n  initializeComponent(\n    Component: (props: any, parent: Node) => () => TemplateResult,\n    parent: Node,\n    props: any\n  ) {\n    //initialize cleanups for component. this includes:\n    //1. general component cleanup for all its effects and memos\n    //2. cleanup of the effect created from the function (that returns a template result) the component returns\n    this.cleanups = [];\n\n    //store the function (that returns a template result) the component returns in `htmlFn` for later us\n    let htmlFn: () => TemplateResult;\n    //initialize component effects and memos and store the cleanup (1st cleanup)\n    this.cleanups.push(\n      adaptSyncEffect(() => (htmlFn = Component(props, parent)), [])\n    );\n\n    //create effect the re-runs component return function and renders the template result upon any state change\n    const [\n      ComponentCleanup,\n      ComponentDependencyUpdate,\n      [htmlTemplateResult],\n    ]: any = adaptSyncEffect(\n      (_, [htmlTemplateResult]: [TemplateResult]) =>\n        renderComponent(this, htmlTemplateResult),\n      [htmlFn],\n      { defer: true, isComponent: true }\n    );\n\n    //store 2nd cleanup\n    this.cleanups.push(ComponentCleanup);\n    //store reference to function used to update component return function dependencies and return template\n    //result for rendering\n    this.ComponentDependencyUpdate = ComponentDependencyUpdate;\n\n    this.Component = () => {\n      //check \"changed\" flag to prevent multiple redundant re-rendering of components.\n      if (this.changed) {\n        this.changed = false;\n        queueRevertChangedToTrue(this);\n\n        const [htmlTemplateResult] = this.ComponentDependencyUpdate?.();\n\n        return htmlTemplateResult;\n      } else {\n        return noChange;\n      }\n    };\n\n    //initialize \"changed\" flag as true.\n    this.changed = true;\n    //prevent re-initialization of component on subsequent renders after initialization.\n    this.updateFlag = \"externalRender\";\n\n    return htmlTemplateResult;\n  }\n\n  update(\n    part: ChildPart,\n    [Component, props]: [\n      (props: any, parent: Node) => () => TemplateResult,\n      any\n    ]\n  ) {\n    //initialize component for the first time or go through normal rendering processes based on the state of `updateFlag`\n    return this[this.updateFlag](props, part, Component);\n  }\n\n  protected reconnected(): void {\n    this.updateFlag = \"initialize\";\n  }\n\n  render() {\n    return this.Component();\n  }\n}\n\ndeclare function hFunc(\n  Component: () => () => TemplateResult,\n  props?: null\n): DirectiveResult;\n\ndeclare function hFunc<Type>(\n  Component: Component<Type>,\n  props: Type\n): DirectiveResult;\n\nconst h: typeof hFunc = directive($);\n\nexport default h;\n","import { AsyncDirective } from \"lit-html/async-directive\";\n\ntype hAsyncDirective = AsyncDirective & { changed: boolean };\n\nconst changedArray1: hAsyncDirective[] = [];\nconst changedArray2: hAsyncDirective[] = [];\nlet one = true;\n\nexport default function queueRevertChangedToTrue(\n  componentAsyncDirective: hAsyncDirective\n) {\n  const changedArray = one ? changedArray1 : changedArray2;\n  const newOne = one ? false : true;\n\n  changedArray.push(componentAsyncDirective);\n\n  if (changedArray.length === 1) {\n    queueMicrotask(() => {\n      one = newOne;\n      changedArray.forEach(\n        (componentAsyncDirective) => (componentAsyncDirective.changed = true)\n      );\n      changedArray.length = 0;\n    });\n  }\n}\n","import { TemplateResult } from \"lit-html\";\nimport { AsyncDirective } from \"lit-html/async-directive.js\";\n\nconst renderArray1: AsyncDirective[] = [];\nconst renderArray2: AsyncDirective[] = [];\nlet one: boolean = true;\n\nfunction renderComponent(\n  componentAsyncDirective: AsyncDirective,\n  htmlTemplateResult: TemplateResult\n) {\n  const renderArray = one ? renderArray1 : renderArray2;\n  const newOne = one ? false : true;\n\n  renderArray.push(componentAsyncDirective);\n\n  if (renderArray.length === 1) {\n    queueMicrotask(() => {\n      one = newOne;\n\n      renderArray.forEach((componentAsyncDirective) => {\n        componentAsyncDirective.setValue(htmlTemplateResult);\n      });\n\n      renderArray.length = 0;\n    });\n  }\n}\n\nexport { renderComponent };\n","import { Getter } from \"../adaptState/stateTypes\";\nimport createEffect from \"./createEffect\";\nimport { EffectFn, EffectOptions } from \"./effectTypes\";\n\nexport default function adaptSyncEffect<T>(\n  fn: EffectFn<T>,\n  depArray?: Getter<any>[],\n  options?: EffectOptions\n) {\n  const [execute, effect] = createEffect(\"sync\", fn, depArray);\n\n  //sync effects are able to return cleanup functions due to their synchronous nature\n  return execute(effect, fn, depArray, options);\n}\n","import executeFns from \"./executeFns\";\nimport sendSignal from \"./sendSignal\";\nimport setInitialParameters from \"../setInitialParameters\";\nimport setCleanupSet from \"../setCleanupSet\";\nimport { Getter } from \"../adaptState/stateTypes\";\nimport { Effect, EffectFn } from \"./effectTypes\";\n\nexport default function createEffect<T>(\n  type: \"async\" | \"sync\" | \"render\",\n  fn: EffectFn<T>,\n  depArray?: Getter<any>[]\n) {\n  //determined if the effect is tracked by the state it uses implicitly, or using the\n  //state provided by its dependency array\n  const tracking = typeof depArray === \"undefined\" ? \"implicit\" : \"depArray\";\n  const execute = executeFns[tracking];\n\n  const effect: Effect = {\n    //whether or not the effect hasn't been ran before\n    firstRun: true,\n    //whether the effect is async, sync or a render effect\n    type,\n    //how the effect is tracked (refer to the `tracking` variable above)\n    tracking,\n    //how many children the effect has\n    childCount: 0,\n    //the number \"n\" that shows that the effect is the \"nth\" child of its parent effect\n    position: null,\n    //how deeply nested the effect is (starting from level one)\n    level: null,\n    //tree-like map data structure that contains the cleanups for every effect in the effect tree\n    cleanupTree: null,\n    //array of digits that point to the effect's cleanup in the effect tree's cleanup tree\n    cleanupTreeNodePointer: null,\n    //subscription sets (async, sync, render, or memo) of every state currently tracking this effect\n    observableSubscriptionSets: new Set(),\n    //used to track the number of state values of states currently tracking the effect that are stale\n    staleStateValuesCount: 0,\n    //used to store the return value of the previous effect execution\n    returnValue: null,\n    //used to notify the effect when a state value of state currently tracking the effect turns\n    //stale or freshens up after turning stale\n    sendSignal: (signal: \"fresh\" | \"stale\"): void =>\n      sendSignal(effect, execute, fn, depArray, signal),\n  };\n\n  //create `cleanupTreeNodePointer` for effect and create `cleanupTree` for effect tree is this is the\n  //topmost parent effect (father of the whole tree)\n  setInitialParameters(effect);\n  //create `cleanupSet` for effect if it doesn't already exist\n  setCleanupSet(effect);\n\n  //return effect `execute` function and effect itself\n  return [execute, effect] as const;\n}\n","import effectAndDescendantCleanup from \"./effectAndDescendantCeanup\";\nimport observableSubscriptionsCleanup from \"../observableSubscriptionsCleanup\";\nimport getCleanupNode from \"../getCleanupNode\";\nimport { effectContexts } from \"../effectContexts\";\nimport { Effect, EffectFn, EffectOptions } from \"./effectTypes\";\nimport { Getter } from \"../adaptState/stateTypes\";\n\nfunction implicitDependencyExecuteFn(effect: Effect, fn: EffectFn) {\n  //set `childCount` back to zero to enable children effects to obtain correct positions upon recreation\n  effect.childCount = 0;\n\n  //fire cleanups make sure proceedings go smoothly\n  const cleanupSet = getCleanupNode(effect).get(0) as Set<() => void>;\n  cleanupSet.forEach((cleanup) => {\n    cleanup();\n  });\n  cleanupSet.clear();\n\n  //push effect onto context to enable tracking by state and memos\n  effectContexts.push(effect);\n\n  //call effect with previous return value\n  const fnReturnValue = fn(effect.returnValue);\n  //create `returnValueCleanup` to be called on next run of effect\n  const returnValueCleanup = () => {\n    if (typeof fnReturnValue === \"function\") {\n      //extract new `returnValue` from effect's returned function\n      effect.returnValue = fnReturnValue();\n    }\n  };\n\n  //add cleanup to obtain new return value and remove effect from all old subscriptions\n  cleanupSet\n    .add(returnValueCleanup)\n    .add(() => observableSubscriptionsCleanup(effect));\n\n  //remove effect from context to disable tracking by state and memos\n  effectContexts.pop();\n\n  //return cleanup function for effect and its descendants\n  return () => effectAndDescendantCleanup(effect);\n}\n\nfunction dependencyArrayExecuteFn(\n  effect: Effect,\n  fn: EffectFn,\n  depArray: Getter[],\n  options: EffectOptions = {}\n) {\n  //to enable children effects to obtain correct positions upon recreation\n  effect.childCount = 0;\n\n  //fire cleanups make sure proceedings go smoothly\n  const cleanupSet = getCleanupNode(effect).get(0) as Set<() => void>;\n  cleanupSet.forEach((cleanup) => {\n    cleanup();\n  });\n  cleanupSet.clear();\n\n  //push effect onto context to enable tracking by state and memos\n  effectContexts.push(effect);\n\n  //set tracking to \"implicit\" to enable tracking by state and memos in `depArray`\n  effect.tracking = \"implicit\";\n  const argsArray = depArray.map((state) => state());\n  //set tracking back to \"depArray\" to disable other forms of implicit tracking\n  //(only allow state and memos in `depArray` to track effect)\n  effect.tracking = \"depArray\";\n\n  //if effect is supposed to be deferred, do nothing on the first run\n  if (effect.firstRun && options.defer) {\n    effect.firstRun = false;\n  } else {\n    //call effect with previous return value and previous state values of tracking state and memos in an `argsArray`\n    const fnReturnValue = fn(effect.returnValue, argsArray);\n    //create `returnValueCleanup` to be called on next run of effect\n    const returnValueCleanup = () => {\n      if (typeof fnReturnValue === \"function\") {\n        //extract new `returnValue` from effect's returned function\n        effect.returnValue = fnReturnValue();\n      }\n    };\n\n    //add cleanup to obtain new return value\n    cleanupSet.add(returnValueCleanup);\n  }\n\n  //add cleanup to remove effect from all old subscriptions\n  cleanupSet.add(() => observableSubscriptionsCleanup(effect));\n\n  //remove effect from context to disable tracking by state and memos\n  effectContexts.pop();\n\n  //if effect is a component-wrapping effect, return cleanup function, function to `updateEffectDependencies` outside\n  //normal flow, and `argsArray`\n  //if not, return just the cleanup function\n  const returnExp = options.isComponent\n    ? ([\n        () => effectAndDescendantCleanup(effect),\n        () => updateEffectDependencies(effect, depArray),\n        argsArray,\n      ] as const)\n    : () => effectAndDescendantCleanup(effect);\n\n  return returnExp;\n}\n\n//created for the purpose of component-wrapping effects\nfunction updateEffectDependencies(effect: Effect, depArray: Getter[]) {\n  const cleanupSet = getCleanupNode(effect).get(0) as Set<() => void>;\n  cleanupSet.forEach((cleanup) => {\n    cleanup();\n  });\n  cleanupSet.clear();\n\n  effectContexts.push(effect);\n\n  effect.tracking = \"implicit\";\n  const argsArray = depArray.map((state) => state());\n  effect.tracking = \"depArray\";\n\n  cleanupSet.add(() => observableSubscriptionsCleanup(effect));\n\n  effectContexts.pop();\n\n  return argsArray;\n}\n\nconst executeFns = {\n  implicit: implicitDependencyExecuteFn,\n  depArray: dependencyArrayExecuteFn,\n};\n\nexport default executeFns;\n","import getCleanupNode from \"../getCleanupNode\";\nimport { CleanupTree, Effect } from \"./effectTypes\";\n\nfunction traverseAndEvaluate(cleanupNode: CleanupTree) {\n  let nextChildNode = 0;\n  while (cleanupNode.get(nextChildNode)) {\n    if (nextChildNode === 0) {\n      const cleanupSet = cleanupNode.get(0) as Set<() => void>;\n      cleanupSet.forEach((cleanup) => {\n        cleanup();\n      });\n      cleanupSet.clear();\n    } else {\n      const nextCleanupNode = cleanupNode.get(nextChildNode) as CleanupTree;\n      traverseAndEvaluate(nextCleanupNode);\n    }\n\n    nextChildNode++;\n  }\n}\n\nexport default function effectAndDescendantCleanup(effect: Effect) {\n  const cleanupNode = getCleanupNode(effect);\n  traverseAndEvaluate(cleanupNode);\n}\n","import { CleanupTree, Effect } from \"./adaptEffect/effectTypes\";\n\n//use `cleanupTreeNodePointer` of effect to get `cleanupNode` of effect\n//this is basically the cleanup tree for the effect tree that begins with this effect\nexport default function getCleanupNode(effect: Effect) {\n  let cleanupNode = effect.cleanupTree;\n\n  effect.cleanupTreeNodePointer.forEach((part) => {\n    cleanupNode = cleanupNode.get(part) as CleanupTree;\n  });\n\n  return cleanupNode;\n}\n","import { Effect } from \"./adaptEffect/effectTypes\";\n\nexport default function observableSubscriptionsCleanup(effect: Effect) {\n  effect.observableSubscriptionSets.forEach((observableSubscriptionSet) => {\n    observableSubscriptionSet.delete(effect);\n  });\n  effect.observableSubscriptionSets.clear();\n}\n","import { Effect } from \"./adaptEffect/effectTypes\";\n\n//stack to track effects that are currently being tracked by state and memos\nexport const effectContexts: Effect[] = [];\n","import { Getter } from \"../adaptState/stateTypes\";\nimport addAsyncEffect from \"./addAsyncEffect\";\nimport addRenderEffect from \"./addRenderEffect\";\nimport { Effect, EffectFn, ExecuteFn } from \"./effectTypes\";\n\nexport default function sendSignal(\n  effect: Effect,\n  execute: ExecuteFn,\n  fn: EffectFn,\n  depArray: Getter[],\n  signal: \"stale\" | \"fresh\"\n) {\n  if (signal === \"stale\") {\n    effect.staleStateValuesCount++;\n  } else if (signal === \"fresh\") {\n    effect.staleStateValuesCount--;\n    if (effect.staleStateValuesCount <= 0) {\n      //to make sure \"effect.stateStateValuesCount\" doesn't go beyond zero\n      effect.staleStateValuesCount = 0;\n      executeMap[effect.type](effect, execute, fn, depArray);\n    }\n  }\n}\n\nconst executeMap = {\n  sync: (\n    effect: Effect,\n    execute: ExecuteFn,\n    fn: EffectFn,\n    depArray: Getter[]\n  ) => execute(effect, fn, depArray),\n  async: (\n    effect: Effect,\n    execute: ExecuteFn,\n    fn: EffectFn,\n    depArray: Getter[]\n  ) => addAsyncEffect(() => execute(effect, fn, depArray)),\n  render: (\n    effect: Effect,\n    execute: ExecuteFn,\n    fn: EffectFn,\n    depArray: Getter[]\n  ) => addRenderEffect(() => execute(effect, fn, depArray)),\n};\n","import { ExecuteFn } from \"./effectTypes\";\n\nconst asyncEffectAndCleanupArray1 = [];\nconst asyncEffectAndCleanupArray2 = [];\nlet one = true;\n\nexport default function addAsyncEffect(executeFn: ExecuteFn) {\n  const asyncEffectAndCleanupArray = one\n    ? asyncEffectAndCleanupArray1\n    : asyncEffectAndCleanupArray2;\n  const newOne = one ? false : true;\n\n  asyncEffectAndCleanupArray.push(executeFn);\n\n  if (asyncEffectAndCleanupArray.length === 1) {\n    setTimeout(() => {\n      one = newOne;\n      asyncEffectAndCleanupArray.forEach((executeFn) => executeFn());\n      asyncEffectAndCleanupArray.length = 0;\n    });\n  }\n}\n","import { ExecuteFn } from \"./effectTypes\";\n\nconst renderEffectArray1 = [];\nconst renderEffectArray2 = [];\nlet one = true;\n\nexport default function addRenderEffect(executeFn: ExecuteFn) {\n  const renderEffectArray = one ? renderEffectArray1 : renderEffectArray2;\n  const newOne = one ? false : true;\n\n  renderEffectArray.push(executeFn);\n\n  if (renderEffectArray.length === 1) {\n    queueMicrotask(() => {\n      one = newOne;\n      renderEffectArray.forEach((executeFn) => executeFn());\n      renderEffectArray.length = 0;\n    });\n  }\n}\n","import { Effect } from \"./adaptEffect/effectTypes\";\nimport { effectContexts } from \"./effectContexts\";\n\nexport default function setInitialParameters(effect: Effect) {\n  const parentEffect = effectContexts[effectContexts.length - 1];\n  if (parentEffect) {\n    //use \"position\" and \"level\" to determine location of effect cleanup\n    //in cleanup tree\n    //increment the parent effect's child count to account for its new child effect\n    parentEffect.childCount++;\n    //the effect's position \"n\" shows that it's the \"nth\" child of its parent effect\n    effect.position = parentEffect.childCount;\n    //the effect's level shows how many levels deep it is nested (one level deeper than its parent effect)\n    effect.level = parentEffect.level + 1;\n    //all effects in a tree have the same cleanup tree\n    effect.cleanupTree = parentEffect.cleanupTree;\n    //copy parent's `cleanupTreeNodePointer` and continue from there\n    effect.cleanupTreeNodePointer = [...parentEffect.cleanupTreeNodePointer];\n\n    //complete `cleanupTreeNodePointer` for the effect\n    //every number's presence in the array represents an extra level of nesting (eg. one number for the first\n    //and topmost level, three numbers for two levels deeper than the topmost level, etc)\n    //the value \"n\" of every number in the array shows that the effect is the \"nth\" effect in that level of nesting\n    let effectCleanupTreeNodePointerLength =\n      effect.cleanupTreeNodePointer.length;\n    if (effectCleanupTreeNodePointerLength === effect.level) {\n      effect.cleanupTreeNodePointer[effectCleanupTreeNodePointerLength - 1] =\n        effect.position;\n    } else if (effectCleanupTreeNodePointerLength < effect.level) {\n      effect.cleanupTreeNodePointer[effectCleanupTreeNodePointerLength] =\n        effect.position;\n    } else if (effectCleanupTreeNodePointerLength > effect.level) {\n      effect.cleanupTreeNodePointer.pop();\n      effect.cleanupTreeNodePointer[effectCleanupTreeNodePointerLength - 2] =\n        effect.position;\n    }\n  } else {\n    //do this for the topmost parent effect (father of the whole tree)\n    effect.level = 1;\n    effect.position = 1;\n    effect.cleanupTreeNodePointer = [1];\n    effect.cleanupTree = new Map();\n  }\n}\n","import { CleanupTree, Effect } from \"./adaptEffect/effectTypes\";\n\nexport default function setCleanupSet(effect: Effect) {\n  //create variable to store `cleanupNode` of effect and initially set the variable to the cleanup tree\n  let cleanupNode: CleanupTree = effect.cleanupTree;\n\n  //extract the `cleanupNode` from the `cleanupTree` and set it to the `cleanupNode` variable\n  effect.cleanupTreeNodePointer.forEach((part) => {\n    if (!cleanupNode.get(part)) {\n      cleanupNode.set(part, new Map());\n    }\n    cleanupNode = cleanupNode.get(part) as CleanupTree;\n  });\n\n  //set cleanup set for effect if it doesn't already exist in the cleanup map\n  if (!cleanupNode.get(0)) {\n    cleanupNode.set(0, new Set());\n  }\n}\n","import get from \"../get\";\nimport set from \"./set\";\nimport { State, Getter, Setter } from \"./stateTypes\";\n\nexport default function adaptState<T = any>(initialValue?: T) {\n  //create state object with three sets of subscriptions\n  const state: State<T> = {\n    //one for sync effect subscriptions\n    //use two sets to effectively manage synchronous subscriptions (prevents recursive filling\n    //and running of effects resulting in stack overflow)\n    syncSubscriptions: {\n      one: new Set(),\n      two: new Set(),\n    },\n    //one for memo subscriptions\n    //use two sets to effectively manage synchronous subscriptions (prevents recursive filling\n    //and running of memos resulting in stack overflow)\n    memoSubscriptions: {\n      one: new Set(),\n      two: new Set(),\n    },\n    //one for async and render effect subscriptions\n    //one set is enough to manage asynchronous effects\n    asyncAndRenderSubscriptions: new Set(),\n    //use variable to effectively switch between subscription sets (for sync effects and memos)\n    activeSubscriptions: \"one\",\n    value: initialValue,\n  };\n\n  const getter = () => get(state);\n  const setter = (nextValue: T) => set(state, nextValue);\n\n  return [getter, setter];\n}\n","import { effectContexts } from \"./effectContexts\";\nimport { State } from \"./adaptState/stateTypes\";\nimport { Effect } from \"./adaptEffect/effectTypes\";\n\nfunction subscribe<T = any>(state: State<T>, effect: Effect) {\n  //get active subscriptions to properly manage sync effects and memos\n  const activeSubscriptions = state.activeSubscriptions;\n  const type = effect.type;\n\n  //if `effect.tracking` is equal to \"depArray\", don't track effects because the tracking\n  //will be done explicitly using the provided dependency array\n  if (effect.tracking === \"depArray\") return;\n\n  //track effects using the right subscription sets, based on whether they are async, render,\n  //sync effects, or memos\n  if (type === \"async\" || type === \"render\") {\n    //tracking async and render effects\n    state.asyncAndRenderSubscriptions.add(effect);\n    effect.observableSubscriptionSets.add(state.asyncAndRenderSubscriptions);\n  } else {\n    //tracking sync effects and memos\n    state[`${type}Subscriptions`][activeSubscriptions].add(effect);\n    effect.observableSubscriptionSets.add(\n      state[`${type}Subscriptions`][activeSubscriptions]\n    );\n  }\n}\n\nexport default function get<T = any>(state: State<T>) {\n  const currentEffect = effectContexts[effectContexts.length - 1];\n  if (currentEffect) {\n    subscribe(state, currentEffect);\n  }\n\n  return state.value;\n}\n","import { updateMemoCleanups } from \"../cleanupUpdateFns\";\nimport { sendStaleSignals, sendFreshSignals } from \"../sendSignals\";\nimport { State } from \"./stateTypes\";\n\nexport default function set<T>(state: State<T>, nextValue: T) {\n  //get active subscriptions to properly manange sync effects and memos\n  const activeSubscriptions = state.activeSubscriptions;\n  //toggle active subscriptions\n  state.activeSubscriptions = activeSubscriptions === \"one\" ? \"two\" : \"one\";\n\n  //let subscriptions know that they have a stale value so that they can notify their\n  //subscriptions if any\n  sendStaleSignals(state, activeSubscriptions);\n\n  //update state value\n  state.value = nextValue;\n\n  //let subscriptions know that their stale value has been updated so that they can notify and\n  //update themselves and their subscriptions if any\n  sendFreshSignals(state, activeSubscriptions);\n\n  //update memo cleanups after all effects have been fired to ensure that no memos are run twice, triggering their effects\n  updateMemoCleanups();\n}\n","const cleanupUpdateArray: (() => void)[] = [];\n\nexport function queueCleanupUpdates(cleanupUpdateFn: () => void) {\n  cleanupUpdateArray.push(cleanupUpdateFn);\n}\n\nexport function updateMemoCleanups() {\n  cleanupUpdateArray.forEach((cleanupUpdateFn) => cleanupUpdateFn());\n  cleanupUpdateArray.length = 0;\n}\n","import { State } from \"./adaptState/stateTypes\";\n\nfunction sendStaleSignals(state: State, activeSubscriptions: \"one\" | \"two\") {\n  state.memoSubscriptions[activeSubscriptions].forEach((subscription) => {\n    subscription.sendSignal(\"stale\");\n  });\n\n  state.syncSubscriptions[activeSubscriptions].forEach((subscription) => {\n    subscription.sendSignal(\"stale\");\n  });\n\n  state.asyncAndRenderSubscriptions.forEach((subscription) => {\n    subscription.sendSignal(\"stale\");\n  });\n}\n\nfunction sendFreshSignals(state: State, activeSubscriptions: \"one\" | \"two\") {\n  state.memoSubscriptions[activeSubscriptions].forEach((subscription) => {\n    subscription.sendSignal(\"fresh\");\n  });\n\n  state.syncSubscriptions[activeSubscriptions].forEach((subscription) => {\n    subscription.sendSignal(\"fresh\");\n  });\n\n  state.asyncAndRenderSubscriptions.forEach((subscription) => {\n    subscription.sendSignal(\"fresh\");\n  });\n}\n\nexport { sendStaleSignals, sendFreshSignals };\n","import { Getter } from \"../adaptState/stateTypes\";\nimport { EffectFn, EffectOptions } from \"./effectTypes\";\nimport createEffect from \"./createEffect\";\n\nexport default function adaptEffect<T = any>(\n  fn: EffectFn<T>,\n  depArray?: Getter<any>[],\n  options?: EffectOptions\n) {\n  const [execute, effect] = createEffect(\"async\", fn, depArray);\n\n  //execute effect asynchronously after next screen paint\n  setTimeout(() => execute(effect, fn, depArray, options));\n}\n","import createEffect from \"./createEffect\";\nimport { Getter } from \"../adaptState/stateTypes\";\nimport { EffectFn, EffectOptions } from \"./effectTypes\";\n\nexport default function adaptRenderEffect<T>(\n  fn: EffectFn<T>,\n  depArray?: Getter<any>[],\n  options?: EffectOptions\n) {\n  const [execute, effect] = createEffect(\"render\", fn, depArray);\n\n  //execute effect asynchronously before next screen paint\n  queueMicrotask(() => execute(effect, fn, depArray, options));\n}\n","import sendSignal from \"./sendSignal\";\nimport get from \"../get\";\nimport setInitialParameters from \"../setInitialParameters\";\nimport setCleanupSet from \"../setCleanupSet\";\nimport { updateValueAndSendFreshNotifications } from \"./notifyAndUpdate\";\nimport { Memo } from \"./memoTypes\";\nimport { Getter } from \"../adaptState/stateTypes\";\n\nexport default function adaptMemo<T = any>(fn: () => T): Getter<T> {\n  const memo: Memo = {\n    //state properties\n    syncSubscriptions: {\n      one: new Set(),\n      two: new Set(),\n    },\n    memoSubscriptions: {\n      one: new Set(),\n      two: new Set(),\n    },\n    asyncAndRenderSubscriptions: new Set(),\n    activeSubscriptions: \"one\",\n    value: null,\n    //effect properties\n    firstRun: true,\n    type: \"memo\",\n    childCount: 0,\n    position: null,\n    level: null,\n    cleanupTree: null,\n    cleanupTreeNodePointer: null,\n    observableSubscriptionSets: new Set(),\n    staleStateValuesCount: 0,\n    sendSignal: (signal) => sendSignal(memo, fn, signal),\n  };\n\n  setInitialParameters(memo);\n  setCleanupSet(memo);\n\n  const cleanupMemo = updateValueAndSendFreshNotifications(memo, fn);\n\n  return cleanupMemo ? () => get<T>(cleanupMemo) : () => get<T>(memo);\n}\n","import {\n  sendStaleNotifications,\n  updateValueAndSendFreshNotifications,\n} from \"./notifyAndUpdate\";\n\nexport default function sendSignal(memo, fn, signal) {\n  if (signal === \"stale\") {\n    memo.staleStateValuesCount++;\n    if (memo.staleStateValuesCount === 1) {\n      sendStaleNotifications(memo);\n    }\n  } else if (signal === \"fresh\") {\n    memo.staleStateValuesCount--;\n    if (memo.staleStateValuesCount <= 0) {\n      //to make sure \"memo.stateStateValuesCount\" doesn't go beyond zero\n      memo.staleStateValuesCount = 0;\n      updateValueAndSendFreshNotifications(memo, fn);\n    }\n  }\n}\n","import observableSubscriptionsCleanup from \"../observableSubscriptionsCleanup\";\nimport getCleanupNode from \"../getCleanupNode\";\nimport { effectContexts } from \"../effectContexts\";\nimport { queueCleanupUpdates } from \"../cleanupUpdateFns\";\nimport { sendStaleSignals, sendFreshSignals } from \"../sendSignals\";\nimport { Memo } from \"./memoTypes\";\n\nexport function sendStaleNotifications(memo: Memo) {\n  //get active subscriptions to properly manange sync effects and memos\n  const activeSubscriptions = memo.activeSubscriptions;\n  //toggle active subscriptions\n  memo.activeSubscriptions = activeSubscriptions === \"one\" ? \"two\" : \"one\";\n\n  //let subscriptions know that they have a stale value so that they can notify their\n  //subscriptions if any\n  sendStaleSignals(memo, activeSubscriptions);\n}\n\n//aside from a few caveats, this function basically runs like the execute function of an effect\nexport function updateValueAndSendFreshNotifications(\n  memo: Memo,\n  fn: () => any\n) {\n  //set `childCount` back to zero to enable children effects to obtain correct positions upon recreation\n  memo.childCount = 0;\n\n  //fire cleanups make sure proceedings go smoothly\n  const cleanupSet = getCleanupNode(memo).get(0) as Set<Memo | (() => void)>;\n  for (const cleanup of cleanupSet) {\n    //if cleanup is a memo, return it and exit out of function because this means that if the function continues to run\n    //the memo would potentially run twice and re-trigger all of its dependents\n    if (typeof cleanup !== \"function\") {\n      return cleanup;\n    }\n    cleanup();\n  }\n  cleanupSet.clear();\n\n  //push memo onto context to enable tracking by state and other memos\n  effectContexts.push(memo);\n\n  memo.value = fn();\n\n  if (memo.firstRun) {\n    memo.firstRun = false;\n    //on first run, add cleanup function to cleanupSet\n    cleanupSet.add(() => observableSubscriptionsCleanup(memo));\n  } else {\n    //else add memo to cleanupSet so that the check that runs inside the for of loop above is able to effectively do its job\n    //and prevent memos from running twice, especially when nested in effects that also depend on them or in other \"edge\" cases\n    cleanupSet.add(memo);\n    //then `queueCleanupUpdates` for later for the same reasons mentioned in the comment above\n    queueCleanupUpdates(() => {\n      cleanupSet.clear();\n      cleanupSet.add(() => observableSubscriptionsCleanup(memo));\n    });\n  }\n\n  //remove memo from context to disable tracking by state and other memos\n  effectContexts.pop();\n\n  //get `activeSubscriptions` as the opposite for `memo.activeSubscriptions` because it recently toggled in `sendStaleNotifications`\n  const activeSubscriptions =\n    memo.activeSubscriptions === \"one\" ? \"two\" : \"one\";\n\n  //let subscriptions know that their stale value has been updated so that they can notify and\n  //update themselves and their subscriptions if any\n  sendFreshSignals(memo, activeSubscriptions);\n}\n"],"names":[],"version":3,"file":"nqtui.js.map","sourceRoot":"/"}