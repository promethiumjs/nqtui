{"mappings":"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","sources":["src/nqtui.ts","src/render.ts","src/h.ts","src/queueRevertChangedToTrue.ts","src/adaptations/adaptations.ts","src/adaptations/adaptEffect/adaptSyncEffect.ts","src/adaptations/adaptEffect/createEffect.ts","src/adaptations/adaptEffect/executeFns.ts","src/adaptations/adaptEffect/effectAndDescendantCeanup.ts","src/adaptations/getCleanupNode.ts","src/adaptations/observableSubscriptionsCleanup.ts","src/adaptations/effectContexts.ts","src/adaptations/adaptEffect/sendSignal.ts","src/adaptations/adaptEffect/addAsyncEffect.ts","src/adaptations/adaptEffect/addRenderEffect.ts","src/adaptations/setInitialParameters.ts","src/adaptations/setCleanupSet.ts","src/adaptations/adaptState/adaptState.ts","src/adaptations/get.ts","src/adaptations/adaptState/set.ts","src/adaptations/cleanupUpdateFns.ts","src/adaptations/sendSignals.ts","src/adaptations/adaptEffect/adaptEffect.ts","src/adaptations/adaptEffect/adaptRenderEffect.ts","src/adaptations/adaptMemo/adaptMemo.ts","src/adaptations/adaptMemo/sendSignal.ts","src/adaptations/adaptMemo/notifyAndUpdate.ts"],"sourcesContent":["import { render } from \"./render\";\nimport type { Component } from \"./render\";\nimport type { TemplateResult } from \"lit-html\";\nimport type { DirectiveResult } from \"lit-html/directive.js\";\nimport h from \"./h\";\nimport { html } from \"lit-html\";\nimport adaptState from \"./adaptations/adaptState/adaptState\";\nimport adaptEffect from \"./adaptations/adaptEffect/adaptEffect\";\nimport adaptRenderEffect from \"./adaptations/adaptEffect/adaptRenderEffect\";\nimport adaptSyncEffect from \"./adaptations/adaptEffect/adaptSyncEffect\";\nimport adaptMemo from \"./adaptations/adaptMemo/adaptMemo\";\nimport { classMap } from \"lit-html/directives/class-map.js\";\nimport { styleMap } from \"lit-html/directives/style-map.js\";\nimport { when } from \"lit-html/directives/when.js\";\nimport { choose } from \"lit-html/directives/choose.js\";\nimport { map } from \"lit-html/directives/map.js\";\nimport { repeat } from \"lit-html/directives/repeat.js\";\nimport { join } from \"lit-html/directives/join.js\";\nimport { range } from \"lit-html/directives/range.js\";\nimport { ifDefined } from \"lit-html/directives/if-defined.js\";\nimport { cache } from \"lit-html/directives/cache.js\";\nimport { keyed } from \"lit-html/directives/keyed.js\";\nimport { guard } from \"lit-html/directives/guard.js\";\nimport { live } from \"lit-html/directives/live.js\";\nimport { ref } from \"lit-html/directives/ref.js\";\nimport { createRef } from \"lit-html/directives/ref.js\";\nimport { templateContent } from \"lit-html/directives/template-content.js\";\nimport { unsafeHTML } from \"lit-html/directives/unsafe-html.js\";\nimport { unsafeSVG } from \"lit-html/directives/unsafe-svg.js\";\nimport { until } from \"lit-html/directives/until.js\";\nimport { asyncAppend } from \"lit-html/directives/async-append.js\";\nimport { asyncReplace } from \"lit-html/directives/async-replace.js\";\n\nexport {\n  Component,\n  render,\n  TemplateResult,\n  DirectiveResult,\n  h,\n  html,\n  adaptState,\n  adaptEffect,\n  adaptRenderEffect,\n  adaptSyncEffect,\n  adaptMemo,\n  classMap,\n  styleMap,\n  when,\n  choose,\n  guard,\n  cache,\n  keyed,\n  map,\n  repeat,\n  join,\n  range,\n  live,\n  ifDefined,\n  ref,\n  createRef,\n  templateContent,\n  unsafeHTML,\n  unsafeSVG,\n  until,\n  asyncAppend,\n  asyncReplace,\n};\n","import {\n  render as internalRender,\n  html,\n  TemplateResult,\n  RootPart,\n} from \"lit-html\";\nimport h from \"./h\";\n\n/**\n * This is the component type\n */\nexport type Component<T = null> = T extends null\n  ? (props?: null) => () => TemplateResult\n  : (props: T) => () => TemplateResult;\n\n/**\n * This is the render function\n */\nexport function render(\n  Component: Component<{\n    renderContainer: string | HTMLElement | DocumentFragment;\n    renderOptions?: Object;\n  }>,\n  props: {\n    renderContainer: string | HTMLElement | DocumentFragment;\n    renderOptions?: Object;\n  }\n): () => RootPart {\n  //check whether or not \"renderContainer\" is a string and handle it\n  //accordingly.\n  if (\n    typeof props.renderContainer === \"string\" ||\n    props.renderContainer instanceof String\n  )\n    props.renderContainer = document.querySelector(\n      props.renderContainer as any\n    );\n\n  const renderComponent = () =>\n    internalRender(\n      html`${h(Component, props)}`,\n      props.renderContainer as HTMLElement | DocumentFragment,\n      props.renderOptions\n    );\n\n  //queue microtask to render the component to enable all extensions to run first.\n  queueMicrotask(renderComponent);\n\n  //return \"renderComponent\" function to allow re-rendering of whole root\n  //component tree.\n  return renderComponent;\n}\n","import {\n  AsyncDirective,\n  directive,\n  DirectiveResult,\n  PartInfo,\n} from \"lit-html/async-directive.js\";\nimport queueRevertChangedToTrue from \"./queueRevertChangedToTrue\";\nimport { renderComponent } from \"./adaptations/adaptations\";\nimport adaptSyncEffect from \"./adaptations/adaptEffect/adaptSyncEffect\";\nimport { ChildPart, noChange, TemplateResult } from \"lit-html\";\nimport { Component } from \"./render\";\n\nclass $ extends AsyncDirective {\n  initialization: boolean;\n  cleanups: (() => void)[];\n  ComponentDependencyUpdate: any;\n  Component: () => TemplateResult;\n  changed: boolean;\n  props: any;\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n\n    //boolean flag to enable initialization of the component in the update method.\n    this.initialization = true;\n  }\n\n  initializeComponent(\n    Component: (props: any, parent: Node) => () => TemplateResult,\n    parent: Node,\n    props: any\n  ) {\n    this.cleanups = [];\n\n    let htmlFn: () => TemplateResult;\n    this.cleanups.push(\n      adaptSyncEffect(() => (htmlFn = Component(props, parent)), [])\n    );\n\n    const [ComponentCleanup, ComponentDependencyUpdate, [htmlTemplateResult]] =\n      adaptSyncEffect(\n        (_, [htmlTemplateResult]) => renderComponent(this, htmlTemplateResult),\n        [htmlFn],\n        { defer: true, isComponent: true }\n      );\n\n    this.cleanups.push(ComponentCleanup);\n    this.ComponentDependencyUpdate = ComponentDependencyUpdate;\n\n    this.Component = () => {\n      //check \"changed\" flag to prevent multiple redundant re-rendering of components.\n      if (this.changed) {\n        this.changed = false;\n        queueRevertChangedToTrue(this);\n\n        const [htmlTemplateResult] = this.ComponentDependencyUpdate?.();\n\n        return htmlTemplateResult;\n      } else {\n        return noChange;\n      }\n    };\n\n    //initialize \"changed\" flag as true.\n    this.changed = true;\n    //prevent re-initialization of component on subsequent renders after initialization.\n    this.initialization = false;\n\n    return htmlTemplateResult;\n  }\n\n  disconnected() {\n    this.cleanups.forEach((cleanup) => cleanup());\n  }\n\n  update(\n    part: ChildPart,\n    [Component, props]: [\n      (props: any, parent: Node) => () => TemplateResult,\n      any\n    ]\n  ) {\n    //initialize component on first render\n    if (this.initialization) {\n      this.props = props;\n      return this.initializeComponent(Component, part.parentNode, this.props);\n    }\n\n    for (const prop in props) {\n      this.props[prop] = props[prop];\n    }\n\n    return this.render();\n  }\n\n  render() {\n    return this.Component();\n  }\n}\n\ndeclare function hFunc(\n  Component: () => () => TemplateResult,\n  props?: null\n): DirectiveResult;\n\ndeclare function hFunc<Type>(\n  Component: Component<Type>,\n  props: Type\n): DirectiveResult;\n\nconst h: typeof hFunc = directive($);\n\nexport default h;\n","const changedArray1 = [];\nconst changedArray2 = [];\nlet one = true;\n\nexport default function queueRevertChangedToTrue(componentAsyncDirective) {\n  if (one) {\n    changedArray1.push(componentAsyncDirective);\n\n    if (changedArray1.length === 1) {\n      queueMicrotask(() => {\n        one = false;\n        changedArray1.forEach(\n          (componentAsyncDirective) => (componentAsyncDirective.changed = true)\n        );\n        changedArray1.length = 0;\n      });\n    }\n  } else {\n    changedArray2.push(componentAsyncDirective);\n\n    if (changedArray2.length === 1) {\n      queueMicrotask(() => {\n        one = true;\n        changedArray2.forEach(\n          (componentAsyncDirective) => (componentAsyncDirective.changed = true)\n        );\n        changedArray2.length = 0;\n      });\n    }\n  }\n}\n","import { TemplateResult } from \"lit-html\";\nimport { AsyncDirective } from \"lit-html/async-directive.js\";\n\nconst renderArray1: AsyncDirective[] = [];\nconst renderArray2: AsyncDirective[] = [];\nlet one: boolean = true;\n\nfunction renderComponent(\n  componentAsyncDirective: AsyncDirective,\n  htmlTemplateResult: TemplateResult\n) {\n  if (one) {\n    renderArray1.push(componentAsyncDirective);\n\n    if (renderArray1.length === 1) {\n      queueMicrotask(() => {\n        one = false;\n\n        renderArray1.forEach((componentAsyncDirective) => {\n          componentAsyncDirective.setValue(htmlTemplateResult);\n        });\n\n        renderArray1.length = 0;\n      });\n    }\n  } else {\n    renderArray2.push(componentAsyncDirective);\n\n    if (renderArray2.length === 1) {\n      queueMicrotask(() => {\n        one = true;\n\n        renderArray2.forEach((componentAsyncDirective) => {\n          componentAsyncDirective.setValue(htmlTemplateResult);\n        });\n\n        renderArray2.length = 0;\n      });\n    }\n  }\n}\n\nexport { renderComponent };\n","import { Getter } from \"../adaptState/stateTypes\";\nimport createEffect from \"./createEffect\";\nimport { EffectFn, EffectOptions } from \"./effectTypes\";\n\nexport function adaptSyncEffect<T>(fn: EffectFn<T>): void;\n\nexport function adaptSyncEffect<T>(\n  fn: EffectFn<T>,\n  depArray: Getter<any>[],\n  options?: EffectOptions\n): void;\n\nexport default function adaptSyncEffect<T>(\n  fn: EffectFn<T>,\n  depArray?: Getter<any>[],\n  options?: EffectOptions\n) {\n  const [execute, effect] = createEffect(\"sync\", fn, depArray);\n\n  //sync effects are able to return cleanup functions due to their synchronous nature\n  return execute(effect, fn, depArray, options);\n}\n","import executeFns from \"./executeFns\";\nimport sendSignal from \"./sendSignal\";\nimport setInitialParameters from \"../setInitialParameters\";\nimport setCleanupSet from \"../setCleanupSet\";\nimport { Getter } from \"../adaptState/stateTypes\";\nimport { Effect, EffectFn } from \"./effectTypes\";\n\nexport default function createEffect<T>(\n  type: \"async\" | \"sync\" | \"render\",\n  fn: EffectFn<T>,\n  depArray?: Getter<any>[]\n) {\n  //determined if the effect is tracked by the state it uses implicitly, or using the\n  //state provided by its dependency array\n  const tracking = typeof depArray === \"undefined\" ? \"implicit\" : \"depArray\";\n  const execute = executeFns[tracking];\n\n  const effect: Effect = {\n    //whether or not the effect hasn't been ran before\n    firstRun: true,\n    //whether the effect is async, sync or a render effect\n    type,\n    //how the effect is tracked (refer to the `tracking` variable above)\n    tracking,\n    //how many children the effect has\n    childCount: 0,\n    //the number \"n\" that shows that the effect is the \"nth\" child of its parent effect\n    position: null,\n    //how deeply nested the effect is (starting from level one)\n    level: null,\n    //tree-like map data structure that contains the cleanups for every effect in the effect tree\n    cleanupTree: null,\n    //array of digits that point to the effect's cleanup in the effect tree's cleanup tree\n    cleanupTreeNodePointer: null,\n    //subscription sets (async, sync, render, or memo) of every state currently tracking this effect\n    observableSubscriptionSets: new Set(),\n    //used to track the number of state values of states currently tracking the effect that are stale\n    staleStateValuesCount: 0,\n    //used to notify the effect when a state value of state currently tracking the effect turns\n    //stale or freshens up after turning stale\n    sendSignal: (signal: \"fresh\" | \"stale\"): void =>\n      sendSignal(effect, execute, fn, depArray, signal),\n  };\n\n  setInitialParameters(effect);\n  setCleanupSet(effect);\n\n  return [execute, effect];\n}\n","import effectAndDescendantCleanup from \"./effectAndDescendantCeanup\";\nimport observableSubscriptionsCleanup from \"../observableSubscriptionsCleanup\";\nimport getCleanupNode from \"../getCleanupNode\";\nimport { effectContexts } from \"../effectContexts\";\nimport { EffectOptions } from \"./effectTypes\";\n\nfunction implicitDependencyExecuteFn(effect, fn) {\n  //to enable children effects to obtain correct positions upon recreation\n  effect.childCount = 0;\n\n  const cleanupSet = getCleanupNode(effect).get(0);\n  cleanupSet.forEach((cleanup) => {\n    cleanup();\n  });\n  cleanupSet.clear();\n\n  effectContexts.push(effect);\n\n  const fnReturnValue = fn(effect.returnValue);\n  const returnValueCleanup = () => {\n    if (typeof fnReturnValue === \"function\") {\n      effect.returnValue = fnReturnValue();\n    }\n  };\n  cleanupSet\n    .add(returnValueCleanup)\n    .add(() => observableSubscriptionsCleanup(effect));\n\n  effectContexts.pop();\n\n  return () => effectAndDescendantCleanup(effect);\n}\n\nfunction dependencyArrayExecuteFn(\n  effect,\n  fn,\n  depArray,\n  options: EffectOptions = {}\n) {\n  //to enable children effects to obtain correct positions upon recreation\n  effect.childCount = 0;\n\n  const cleanupSet = getCleanupNode(effect).get(0);\n  cleanupSet.forEach((cleanup) => {\n    cleanup();\n  });\n  cleanupSet.clear();\n\n  effectContexts.push(effect);\n\n  effect.tracking = \"implicit\";\n  const argsArray = depArray.map((state) => state());\n  effect.tracking = \"depArray\";\n\n  if (effect.firstRun && options.defer) {\n    effect.firstRun = false;\n  } else {\n    const fnReturnValue = fn(effect.returnValue, argsArray);\n    const returnValueCleanup = () => {\n      if (typeof fnReturnValue === \"function\") {\n        effect.returnValue = fnReturnValue();\n      }\n    };\n    cleanupSet.add(returnValueCleanup);\n  }\n  cleanupSet.add(() => observableSubscriptionsCleanup(effect));\n\n  effectContexts.pop();\n\n  const returnExp = options.isComponent\n    ? [\n        () => effectAndDescendantCleanup(effect),\n        () => updateEffectDependencies(effect, depArray),\n        argsArray,\n      ]\n    : () => effectAndDescendantCleanup(effect);\n\n  return returnExp;\n}\n\n//created for the purpose of component-wrapping effects\nfunction updateEffectDependencies(effect, depArray) {\n  const cleanupSet = getCleanupNode(effect).get(0);\n  cleanupSet.forEach((cleanup) => {\n    cleanup();\n  });\n  cleanupSet.clear();\n\n  effectContexts.push(effect);\n\n  effect.tracking = \"implicit\";\n  const argsArray = depArray.map((state) => state());\n  effect.tracking = \"depArray\";\n\n  cleanupSet.add(() => observableSubscriptionsCleanup(effect));\n\n  effectContexts.pop();\n\n  return argsArray;\n}\n\nconst executeFns = {\n  implicit: implicitDependencyExecuteFn,\n  depArray: dependencyArrayExecuteFn,\n};\n\nexport default executeFns;\n","import getCleanupNode from \"../getCleanupNode\";\n\nfunction traverseAndEvaluate(cleanupNode) {\n  let nextChildNode = 0;\n  while (cleanupNode.get(nextChildNode)) {\n    if (nextChildNode === 0) {\n      const cleanupSet = cleanupNode.get(0);\n      cleanupSet.forEach((cleanup) => {\n        cleanup();\n      });\n      cleanupSet.clear();\n    } else {\n      const nextCleanupNode = cleanupNode.get(nextChildNode);\n      traverseAndEvaluate(nextCleanupNode);\n    }\n\n    nextChildNode++;\n  }\n}\n\nexport default function effectAndDescendantCleanup(effect) {\n  const cleanupNode = getCleanupNode(effect);\n  traverseAndEvaluate(cleanupNode);\n}\n","export default function getCleanupNode(effect) {\n  let cleanupNode = effect.cleanupTree;\n  effect.cleanupTreeNodePointer.forEach((part) => {\n    cleanupNode = cleanupNode.get(part);\n  });\n\n  return cleanupNode;\n}\n","export default function observableSubscriptionsCleanup(effect) {\n  effect.observableSubscriptionSets.forEach((observableSubscriptionSet) => {\n    observableSubscriptionSet.delete(effect);\n  });\n  effect.observableSubscriptionSets.clear();\n}\n","import { Effect } from \"./adaptEffect/effectTypes\";\n\n//stack to track effects that are currently being tracked by state and memos\nexport const effectContexts: Effect[] = [];\n","import addAsyncEffect from \"./addAsyncEffect\";\nimport addRenderEffect from \"./addRenderEffect\";\n\nexport default function sendSignal(effect, execute, fn, depArray, signal) {\n  if (signal === \"stale\") {\n    effect.staleStateValuesCount++;\n  } else if (signal === \"fresh\") {\n    effect.staleStateValuesCount--;\n    if (effect.staleStateValuesCount <= 0) {\n      //to make sure \"effect.stateStateValuesCount\" doesn't go beyond zero\n      effect.staleStateValuesCount = 0;\n      executeMap[effect.type](effect, execute, fn, depArray);\n    }\n  }\n}\n\nconst executeMap = {\n  sync: (effect, execute, fn, depArray) => execute(effect, fn, depArray),\n  async: (effect, execute, fn, depArray) =>\n    addAsyncEffect(() => execute(effect, fn, depArray)),\n  render: (effect, execute, fn, depArray) =>\n    addRenderEffect(() => execute(effect, fn, depArray)),\n};\n","const asyncEffectAndCleanupArray1 = [];\nconst asyncEffectAndCleanupArray2 = [];\nlet one = true;\n\nexport default function addAsyncEffect(executeFn) {\n  if (one) {\n    asyncEffectAndCleanupArray1.push(executeFn);\n\n    if (asyncEffectAndCleanupArray1.length === 1) {\n      setTimeout(() => {\n        one = false;\n        asyncEffectAndCleanupArray1.forEach((executeFn) => executeFn());\n        asyncEffectAndCleanupArray1.length = 0;\n      });\n    }\n  } else {\n    asyncEffectAndCleanupArray2.push(executeFn);\n\n    if (asyncEffectAndCleanupArray2.length === 1) {\n      setTimeout(() => {\n        one = true;\n        asyncEffectAndCleanupArray2.forEach((executeFn) => executeFn());\n        asyncEffectAndCleanupArray2.length = 0;\n      });\n    }\n  }\n}\n","const renderEffectArray1 = [];\nconst renderEffectArray2 = [];\nlet one = true;\n\nexport default function addRenderEffect(executeFn) {\n  if (one) {\n    renderEffectArray1.push(executeFn);\n\n    if (renderEffectArray1.length === 1) {\n      queueMicrotask(() => {\n        one = false;\n        renderEffectArray1.forEach((executeFn) => executeFn());\n        renderEffectArray1.length = 0;\n      });\n    }\n  } else {\n    renderEffectArray2.push(executeFn);\n\n    if (renderEffectArray2.length === 1) {\n      queueMicrotask(() => {\n        one = true;\n        renderEffectArray2.forEach((executeFn) => executeFn());\n        renderEffectArray2.length = 0;\n      });\n    }\n  }\n}\n","import { Effect } from \"./adaptEffect/effectTypes\";\nimport { effectContexts } from \"./effectContexts\";\n\nexport default function setInitialParameters(effect: Effect) {\n  const parentEffect = effectContexts[effectContexts.length - 1];\n  if (parentEffect) {\n    //use \"position\" and \"level\" to determine location of effect cleanup\n    //in cleanup tree\n    //increment the parent effect's child count to account for its new child effect\n    parentEffect.childCount++;\n    //the effect's position \"n\" shows that it's the \"nth\" child of its parent effect\n    effect.position = parentEffect.childCount;\n    //the effect's level shows how many levels deep it is nested (one level deeper than its parent effect)\n    effect.level = parentEffect.level + 1;\n    //all effects in a tree have the same cleanup tree\n    effect.cleanupTree = parentEffect.cleanupTree;\n    //copy parent's `cleanupTreeNodePointer` and continue from there\n    effect.cleanupTreeNodePointer = [...parentEffect.cleanupTreeNodePointer];\n\n    //complete `cleanupTreeNodePointer` for the effect\n    //every number's presence in the array represents an extra level of nesting (eg. one number for the first\n    //and topmost level, three numbers for two levels deeper than the topmost level, etc)\n    //the value \"n\" of every number in the array shows that the effect is the \"nth\" effect in that level of nesting\n    let effectCleanupTreeNodePointerLength =\n      effect.cleanupTreeNodePointer.length;\n    if (effectCleanupTreeNodePointerLength === effect.level) {\n      effect.cleanupTreeNodePointer[effectCleanupTreeNodePointerLength - 1] =\n        effect.position;\n    } else if (effectCleanupTreeNodePointerLength < effect.level) {\n      effect.cleanupTreeNodePointer[effectCleanupTreeNodePointerLength] =\n        effect.position;\n    } else if (effectCleanupTreeNodePointerLength > effect.level) {\n      effect.cleanupTreeNodePointer.pop();\n      effect.cleanupTreeNodePointer[effectCleanupTreeNodePointerLength - 2] =\n        effect.position;\n    }\n  } else {\n    //do this for the topmost parent effect of the tree\n    effect.level = 1;\n    effect.position = 1;\n    effect.cleanupTreeNodePointer = [1];\n    effect.cleanupTree = new Map();\n  }\n}\n","import { CleanupTree, Effect } from \"./adaptEffect/effectTypes\";\n\nexport default function setCleanupSet(effect: Effect) {\n  //create variable to store `cleanupMap` of effect and initially set the variable to the cleanup tree\n  let cleanupMap: CleanupTree = effect.cleanupTree;\n\n  //extract the `cleanupMap` from the `cleanupTree` and set it to the `cleanupMap` variable\n  effect.cleanupTreeNodePointer.forEach((part) => {\n    if (!cleanupMap.get(part)) {\n      cleanupMap.set(part, new Map());\n    }\n    cleanupMap = cleanupMap.get(part) as CleanupTree;\n  });\n\n  //set cleanup set for effect if it doesn't already exist in the cleanup map\n  if (!cleanupMap.get(0)) {\n    cleanupMap.set(0, new Set());\n  }\n}\n","import get from \"../get\";\nimport set from \"./set\";\nimport { State, Getter, Setter } from \"./stateTypes\";\n\nexport default function adaptState<T = any>(\n  initialValue: T\n): [() => T, (nextValue: T) => void] {\n  //create state object with three sets of subscriptions\n  const state: State<T> = {\n    //one for sync effect subscriptions\n    //use two sets to effectively manage synchronous subscriptions (prevents recursive filling\n    //and running of effects resulting in stack overflow)\n    syncSubscriptions: {\n      one: new Set(),\n      two: new Set(),\n    },\n    //one for memo subscriptions\n    //use two sets to effectively manage synchronous subscriptions (prevents recursive filling\n    //and running of memos resulting in stack overflow)\n    memoSubscriptions: {\n      one: new Set(),\n      two: new Set(),\n    },\n    //one for async and render effect subscriptions\n    //one set is enough to manage asynchronous effects\n    asyncAndRenderSubscriptions: new Set(),\n    //use variable to effectively switch between subscription sets (for sync effects and memos)\n    activeSubscriptions: \"one\",\n    value: initialValue,\n  };\n\n  const getter: Getter<T> = () => get(state);\n  const setter: Setter<T> = (nextValue: T) => set(state, nextValue);\n\n  return [getter, setter];\n}\n","import { effectContexts } from \"./effectContexts\";\nimport { State } from \"./adaptState/stateTypes\";\nimport { Effect } from \"./adaptEffect/effectTypes\";\n\nfunction subscribe<T>(state: State<T>, effect: Effect) {\n  //get active subscriptions to properly manage sync effects and memos\n  const activeSubscriptions = state.activeSubscriptions;\n  const type = effect.type;\n\n  //if `effect.tracking` is equal to \"depArray\", don't track effects because the tracking\n  //will be done explicitly using the provided dependency array\n  if (effect.tracking === \"depArray\") return;\n\n  //track effects using the right subscription sets, based on whether they are async, render,\n  //sync effects, or memos\n  if (type === \"async\" || type === \"render\") {\n    //tracking async and render effects\n    state.asyncAndRenderSubscriptions.add(effect);\n    effect.observableSubscriptionSets.add(state.asyncAndRenderSubscriptions);\n  } else {\n    //tracking sync effects and memos\n    state[`${type}Subscriptions`][activeSubscriptions].add(effect);\n    effect.observableSubscriptionSets.add(\n      state[`${type}Subscriptions`][activeSubscriptions]\n    );\n  }\n}\n\nexport default function get<T>(state: State<T>) {\n  const currentEffect = effectContexts[effectContexts.length - 1];\n  if (currentEffect) {\n    subscribe(state, currentEffect);\n  }\n\n  return state.value;\n}\n","import { updateMemoCleanups } from \"../cleanupUpdateFns\";\nimport { sendStaleSignals, sendFreshSignals } from \"../sendSignals\";\nimport { State } from \"./stateTypes\";\n\nexport default function set<T>(state: State<T>, nextValue: T) {\n  //get active subscriptions to properly manange sync effects and memos\n  const activeSubscriptions = state.activeSubscriptions;\n  state.activeSubscriptions = activeSubscriptions === \"one\" ? \"two\" : \"one\";\n\n  //let subscriptions know that they have a stale value so that they can notify their\n  //subscriptions if any\n  sendStaleSignals(state, activeSubscriptions);\n\n  //update state value\n  state.value = nextValue;\n\n  //let subscriptions know that their stale value has been updated so that they can notify and\n  //update themselves and their subscriptions if any\n  sendFreshSignals(state, activeSubscriptions);\n\n  //functionality required to ensure that memos are fired right and at the right time in some edge cases\n  updateMemoCleanups();\n}\n","const cleanupUpdateArray: (() => void)[] = [];\n\nexport function queueCleanupUpdates(cleanupUpdateFn: () => void) {\n  cleanupUpdateArray.push(cleanupUpdateFn);\n}\n\nexport function updateMemoCleanups() {\n  cleanupUpdateArray.forEach((cleanupUpdateFn) => cleanupUpdateFn());\n  cleanupUpdateArray.length = 0;\n}\n","function sendStaleSignals(state, activeSubscriptions) {\n  state.memoSubscriptions[activeSubscriptions].forEach((subscription) => {\n    subscription.sendSignal(\"stale\");\n  });\n\n  state.syncSubscriptions[activeSubscriptions].forEach((subscription) => {\n    subscription.sendSignal(\"stale\");\n  });\n\n  state.asyncAndRenderSubscriptions.forEach((subscription) => {\n    subscription.sendSignal(\"stale\");\n  });\n}\n\nfunction sendFreshSignals(state, activeSubscriptions) {\n  state.memoSubscriptions[activeSubscriptions].forEach((subscription) => {\n    subscription.sendSignal(\"fresh\");\n  });\n\n  state.syncSubscriptions[activeSubscriptions].forEach((subscription) => {\n    subscription.sendSignal(\"fresh\");\n  });\n\n  state.asyncAndRenderSubscriptions.forEach((subscription) => {\n    subscription.sendSignal(\"fresh\");\n  });\n}\n\nexport { sendStaleSignals, sendFreshSignals };\n","import { Getter } from \"../adaptState/stateTypes\";\nimport { EffectFn, EffectOptions } from \"./effectTypes\";\nimport createEffect from \"./createEffect\";\n\nexport function adaptEffect<T>(fn: EffectFn<T>): void;\n\nexport function adaptEffect<T>(\n  fn: EffectFn<T>,\n  depArray: Getter<any>[],\n  options?: EffectOptions\n): void;\n\nexport default function adaptEffect<T>(\n  fn: EffectFn<T>,\n  depArray?: Getter<any>[],\n  options?: EffectOptions\n) {\n  const [execute, effect] = createEffect(\"async\", fn, depArray);\n\n  //execute effect asynchronously before next screen paint\n  setTimeout(() => execute(effect, fn, depArray, options));\n}\n","import createEffect from \"./createEffect\";\nimport { Getter } from \"../adaptState/stateTypes\";\nimport { EffectFn, EffectOptions } from \"./effectTypes\";\n\nexport function adaptRenderEffect<T>(fn: EffectFn<T>): void;\n\nexport function adaptRenderEffect<T>(\n  fn: EffectFn<T>,\n  depArray: Getter<any>[],\n  options?: EffectOptions\n): void;\n\nexport default function adaptRenderEffect<T>(\n  fn: EffectFn<T>,\n  depArray?: Getter<any>[],\n  options?: EffectOptions\n) {\n  const [execute, effect] = createEffect(\"render\", fn, depArray);\n\n  //execute effect asynchronously after next screen paint\n  queueMicrotask(() => execute(effect, fn, depArray, options));\n}\n","import sendSignal from \"./sendSignal\";\nimport get from \"../get\";\nimport setInitialParameters from \"../setInitialParameters\";\nimport setCleanupSet from \"../setCleanupSet\";\nimport { updateValueAndSendFreshNotifications } from \"./notifyAndUpdate\";\n\nexport default function adaptMemo(fn) {\n  const memo = {\n    //state properties\n    syncSubscriptions: {\n      one: new Set(),\n      two: new Set(),\n    },\n    memoSubscriptions: {\n      one: new Set(),\n      two: new Set(),\n    },\n    asyncAndRenderSubscriptions: new Set(),\n    activeSubscriptions: \"one\",\n    value: null,\n    //effect properties\n    firstRun: true,\n    type: \"memo\",\n    childCount: 0,\n    position: null,\n    level: null,\n    cleanupTree: null,\n    cleanupTreeNodePointer: null,\n    observableSubscriptionSets: new Set(),\n    staleStateValuesCount: 0,\n    sendSignal: (signal) => sendSignal(memo, fn, signal),\n  };\n\n  setInitialParameters(memo);\n  setCleanupSet(memo);\n  const cleanupMemo = updateValueAndSendFreshNotifications(memo, fn);\n\n  return cleanupMemo ? () => get(cleanupMemo) : () => get(memo);\n}\n","import {\n  sendStaleNotifications,\n  updateValueAndSendFreshNotifications,\n} from \"./notifyAndUpdate\";\n\nexport default function sendSignal(memo, fn, signal) {\n  if (signal === \"stale\") {\n    memo.staleStateValuesCount++;\n    if (memo.staleStateValuesCount === 1) {\n      sendStaleNotifications(memo);\n    }\n  } else if (signal === \"fresh\") {\n    memo.staleStateValuesCount--;\n    if (memo.staleStateValuesCount <= 0) {\n      //to make sure \"memo.stateStateValuesCount\" doesn't go beyond zero\n      memo.staleStateValuesCount = 0;\n      updateValueAndSendFreshNotifications(memo, fn);\n    }\n  }\n}\n","import observableSubscriptionsCleanup from \"../observableSubscriptionsCleanup\";\nimport getCleanupNode from \"../getCleanupNode\";\nimport { effectContexts } from \"../effectContexts\";\nimport { queueCleanupUpdates } from \"../cleanupUpdateFns\";\nimport { sendStaleSignals, sendFreshSignals } from \"../sendSignals\";\n\nexport function sendStaleNotifications(memo) {\n  const activeSubscriptions = memo.activeSubscriptions;\n  memo.activeSubscriptions = activeSubscriptions === \"one\" ? \"two\" : \"one\";\n\n  sendStaleSignals(memo, activeSubscriptions);\n}\n\nexport function updateValueAndSendFreshNotifications(memo, fn) {\n  //to enable children effects to obtain correct positions upon recreation\n  memo.childCount = 0;\n\n  const cleanupSet = getCleanupNode(memo).get(0);\n  for (const cleanup of cleanupSet) {\n    if (cleanup.type === \"memo\") {\n      return cleanup;\n    }\n    cleanup();\n  }\n  cleanupSet.clear();\n\n  effectContexts.push(memo);\n\n  memo.value = fn();\n\n  if (memo.firstRun) {\n    memo.firstRun = false;\n    cleanupSet.add(() => observableSubscriptionsCleanup(memo));\n  } else {\n    cleanupSet.add(memo);\n    queueCleanupUpdates(() => {\n      cleanupSet.clear();\n      cleanupSet.add(() => observableSubscriptionsCleanup(memo));\n    });\n  }\n\n  effectContexts.pop();\n\n  const activeSubscriptions =\n    memo.activeSubscriptions === \"one\" ? \"two\" : \"one\";\n\n  sendFreshSignals(memo, activeSubscriptions);\n}\n"],"names":[],"version":3,"file":"nqtui.js.map"}